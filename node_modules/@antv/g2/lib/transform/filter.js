"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filter = void 0;
const util_1 = require("@antv/util");
const helper_1 = require("../utils/helper");
const helper_2 = require("./utils/helper");
function normalizeValue(value) {
    if (typeof value === 'object')
        return [value.value, value.ordinal];
    else
        return [value, true];
}
/**
 * The Filter transform filter channels.
 */
const Filter = (options = {}) => {
    return (I, mark) => {
        const { encode, data } = mark;
        const filters = Object.entries(options)
            .map(([key, v]) => {
            const [V] = (0, helper_2.columnOf)(encode, key);
            // Skip empty channel.
            if (!V)
                return null;
            const [value, ordinal = true] = normalizeValue(v);
            if (typeof value === 'function')
                return (i) => value(V[i]);
            if (ordinal) {
                const expectedValues = Array.isArray(value) ? value : [value];
                // Skip empty expected values.
                if (expectedValues.length === 0)
                    return null;
                return (i) => expectedValues.includes(V[i]);
            }
            else {
                const [start, end] = value;
                return (i) => V[i] >= start && V[i] <= end;
            }
        })
            .filter(helper_1.defined);
        // Skip empty filters.
        if (filters.length === 0)
            return [I, mark];
        // Filter index and channels.
        const totalFilter = (i) => filters.every((f) => f(i));
        const FI = I.filter(totalFilter);
        const newIndex = FI.map((_, i) => i);
        const newEncodes = Object.entries(encode).map(([key, encode]) => {
            return [
                key,
                Object.assign(Object.assign({}, encode), { value: newIndex
                        .map((i) => encode.value[FI[i]])
                        .filter((v) => v !== undefined) }),
            ];
        });
        return [
            newIndex,
            (0, util_1.deepMix)({}, mark, {
                encode: Object.fromEntries(newEncodes),
                // Filter data for tooltip item.
                data: FI.map((i) => data[i]),
            }),
        ];
    };
};
exports.Filter = Filter;
exports.Filter.props = {};
//# sourceMappingURL=filter.js.map